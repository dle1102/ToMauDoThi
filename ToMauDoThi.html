<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Graph Coloring Interface — Compare</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 20px;
        }

        canvas {
            border: 1px solid #333;
            margin-top: 10px;
        }

        button, select {
            margin: 5px;
            padding: 5px 10px;
        }

        table {
            border-collapse: collapse;
            margin: 15px auto;
        }

        th, td {
            border: 1px solid #666;
            padding: 5px 10px;
        }

        #stepDesc {
            margin-top: 10px;
            font-style: italic;
            color: darkblue;
        }
    </style>
</head>
<body>
    <h2>Tô màu đồ thị — So sánh thuật toán</h2>

    <label for="algorithm">Chọn thuật toán:</label>
    <select id="algorithm">
        <option value="greedy">Greedy</option>
        <option value="backtracking">Backtracking (Optimal)</option>
        <option value="dsatur">DSATUR</option>
    </select>
    <br>

    <button onclick="startAlgorithm()">Bắt đầu</button>
    <button onclick="nextStep()">Bước tiếp</button>
    <button onclick="resetColoring()">Reset tô màu</button>
    <button onclick="resetAll()">Reset tất cả</button>

    <div id="stepDesc"></div>
    <canvas id="graphCanvas" width="500" height="400"></canvas>

    <h3>Kết quả chi tiết</h3>
    <table id="resultTable">
        <thead><tr><th>Đỉnh</th><th>Màu</th></tr></thead>
        <tbody></tbody>
    </table>

    <h3>Bảng so sánh thuật toán</h3>
    <table id="compareTable">
        <thead><tr><th>Thuật toán</th><th>Số màu</th><th>Kết quả</th></tr></thead>
        <tbody></tbody>
    </table>

    <script>
        const canvas = document.getElementById("graphCanvas");
        const ctx = canvas.getContext("2d");

        // Đồ thị mẫu (5 đỉnh)
        const vertices = [
            { x: 100, y: 100 }, { x: 250, y: 80 }, { x: 400, y: 120 },
            { x: 180, y: 250 }, { x: 320, y: 260 }
        ];
        const edges = [
            [0, 1], [1, 2], [0, 3], [1, 3], [2, 4], [3, 4]
        ];

        let colors = {};
        let stepIndex = 0;
        let order = [];
        let currentAlgo = "";
        let finished = false;
        let compareResults = [];
        let backtrackSolution = null;

        // Bảng tên màu
        const COLOR_NAMES = ["Đỏ", "Xanh lá", "Xanh dương", "Vàng", "Cam", "Tím", "Hồng", "Nâu"];

        // Vẽ đồ thị
        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.lineWidth = 2;
            edges.forEach(([u, v]) => {
                ctx.beginPath();
                ctx.moveTo(vertices[u].x, vertices[u].y);
                ctx.lineTo(vertices[v].x, vertices[v].y);
                ctx.stroke();
            });
            vertices.forEach((v, i) => {
                ctx.beginPath();
                ctx.arc(v.x, v.y, 25, 0, 2 * Math.PI);
                ctx.fillStyle = colors[i] ? getFillColor(colors[i]) : "white";
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = "black";
                ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.fillText(i, v.x, v.y);
            });
        }

        // Đổi số sang màu thực tế
        function getFillColor(c) {
            const palette = ["#ff4d4d", "#4dff4d", "#4d4dff", "#ffff66", "#ff9933", "#cc66ff", "#ff66b2", "#996633"];
            return palette[c - 1] || "gray";
        }
        function getColorName(c) {
            return COLOR_NAMES[c - 1] || ("Màu " + c);
        }

        // Reset tô màu
        function resetColoring() {
            colors = {};
            stepIndex = 0;
            finished = false;
            backtrackSolution = null;
            document.querySelector("#resultTable tbody").innerHTML = "";
            document.getElementById("stepDesc").innerText = "";
            drawGraph();
        }

        // Reset tất cả
        function resetAll() {
            resetColoring();
            compareResults = [];
            document.querySelector("#compareTable tbody").innerHTML = "";
        }

        // Khởi tạo thuật toán
        function startAlgorithm() {
            resetColoring();
            currentAlgo = document.getElementById("algorithm").value;

            if (currentAlgo === "greedy") {
                order = vertices.map((_, i) => i);
            } else if (currentAlgo === "backtracking") {
                // Tính sẵn nghiệm tối ưu
                backtrackSolution = backtrackingColoring();
                order = Object.keys(backtrackSolution).map(x => parseInt(x));
            } else if (currentAlgo === "dsatur") {
                order = [];
            }

            document.getElementById("stepDesc").innerText =
                "Đã chọn thuật toán " + currentAlgo.toUpperCase() + ". Bấm 'Bước tiếp' để bắt đầu.";
            drawGraph();
        }

        function degree(v) {
            return edges.filter(e => e[0] === v || e[1] === v).length;
        }

        // Backtracking tìm nghiệm tối ưu
        function backtrackingColoring() {
            let n = vertices.length;
            let best = null;
            let colorsTmp = Array(n).fill(0);

            function isSafe(v, c) {
                for (let [u, w] of edges) {
                    if (u === v && colorsTmp[w] === c) return false;
                    if (w === v && colorsTmp[u] === c) return false;
                }
                return true;
            }

            function solve(v, maxColor) {
                if (v === n) {
                    if (!best || maxColor < best.numColors) {
                        best = { numColors: maxColor, assignment: [...colorsTmp] };
                    }
                    return;
                }
                for (let c = 1; c <= maxColor + 1; c++) {
                    if (isSafe(v, c)) {
                        colorsTmp[v] = c;
                        solve(v + 1, Math.max(maxColor, c));
                        colorsTmp[v] = 0;
                    }
                }
            }

            solve(0, 0);
            let result = {};
            best.assignment.forEach((c, i) => result[i] = c);
            return result;
        }

        // Thực hiện 1 bước
        function nextStep() {
            if (finished) return;

            let v;
            if (currentAlgo === "dsatur") {
                let candidates = vertices.map((_, i) => i).filter(i => !(i in colors));
                if (candidates.length === 0) { finishAlgorithm(); return; }
                candidates.sort((a, b) => {
                    let sa = satDeg(a), sb = satDeg(b);
                    if (sa !== sb) return sb - sa;
                    return degree(b) - degree(a);
                });
                v = candidates[0];
            } else {
                if (stepIndex >= order.length) { finishAlgorithm(); return; }
                v = order[stepIndex];
            }

            let c;
            if (currentAlgo === "backtracking") {
                c = backtrackSolution[v];
            } else {
                let used = new Set();
                edges.forEach(([u, w]) => {
                    if (u === v && colors[w]) used.add(colors[w]);
                    if (w === v && colors[u]) used.add(colors[u]);
                });
                c = 1; while (used.has(c)) c++;
            }

            colors[v] = c;
            stepIndex++;

            updateResultTable();
            drawGraph();
            document.getElementById("stepDesc").innerText =
                `Tô đỉnh ${v} bằng ${getColorName(c)}.`;

            if (Object.keys(colors).length === vertices.length) {
                finishAlgorithm();
            }
        }

        function satDeg(v) {
            let neighColors = new Set();
            edges.forEach(([u, w]) => {
                if (u === v && colors[w]) neighColors.add(colors[w]);
                if (w === v && colors[u]) neighColors.add(colors[u]);
            });
            return neighColors.size;
        }

        function updateResultTable() {
            let tbody = document.querySelector("#resultTable tbody");
            tbody.innerHTML = "";
            for (let i = 0; i < vertices.length; i++) {
                let c = colors[i];
                let row = `<tr><td>${i}</td><td>${c ? getColorName(c) : ""}</td></tr>`;
                tbody.innerHTML += row;
            }
        }

        function finishAlgorithm() {
            finished = true;
            document.getElementById("stepDesc").innerText += " — Hoàn thành!";
            let numColors = Math.max(...Object.values(colors));
            let resultStr = Object.entries(colors).map(([v, c]) => `${v}:${getColorName(c)}`).join(", ");
            compareResults.push({ algo: currentAlgo, numColors, resultStr });
            updateCompareTable();
        }

        function updateCompareTable() {
            let tbody = document.querySelector("#compareTable tbody");
            tbody.innerHTML = "";
            compareResults.forEach(r => {
                let row = `<tr><td>${r.algo}</td><td>${r.numColors}</td><td>${r.resultStr}</td></tr>`;
                tbody.innerHTML += row;
            });
        }

        drawGraph();
    </script>
</body>
</html>
